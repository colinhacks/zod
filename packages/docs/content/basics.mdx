---
title: Basic usage
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from "fumadocs-ui/components/callout";
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

This page will walk you through the basics of creating schemas, parsing data, and using inferred types. For complete documentation on Zod's schema API, refer to [Defining schemas](/api).

## Defining a schema

Before you can do anything else, you need to define a schema. For the purposes of this guide, we'll use a simple object schema.

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
import { z } from "zod/v4"; 

const Player = z.object({ 
  username: z.string(),
  xp: z.number()
});
```
</Tab>
<Tab value="Zod Mini">
```ts
import { z } from "zod/v4-mini"

const Player = z.object({ 
  username: z.string(),
  xp: z.number()
});
```
</Tab>
</Tabs>

<Accordions>
<Accordion title='Why the "/v4" suffix?'>
  To allow time for the ecosystem the migrate, there will be a transitionary period in which Zod 4 will be published alongside Zod 3 and consumable as a subpath import:

  ```ts
  import { z } from "zod/v4"
  ```

  During this transition window:

  1. Zod 4 will be considered 100% stable and production-ready
  2. The `"zod"` package will continue to be published in the `3.x.x` version range on npm. The `/v4` subpath will be added in the `zod@3.25` release.
  3. Zod 3 will continue to be exported from the package root (`"zod"`) as well as a new subpath (`"zod/v3"`). It will continue to receive bug fixes & stability improvements.

  Why? Zod occupies a unique place in the ecosystem. Many libraries/frameworks in the ecosystem accept user-defined Zod schemas. This means their user-facing API is strongly coupled to Zod and its various classes/interfaces/utilities. For these libraries/frameworks, a breaking change to Zod necessarily causes a breaking change for their users. A Zod 3 `ZodType` is not assignable to a Zod 4 `ZodType`.

  So why can't libraries just support v3 and v4 simultaneously? Unfortunately the limitations of peerDependencies (and inconsistencies between package managers) make it extremely difficult to elegantly support two major versions of one library simultaneously.

  If I naively published `zod@4.0.0` to npm, the vast majority of the libraries in Zod's ecosystem would need to publish a new major version to properly support Zod 4. this includes some high-profile libraries like the `ai` SDK. it would trigger a "version bump avalanche" across the ecosystem and generally create a huge amount of frustration and work. 
  
  By co-publishing v3 and v4 together, we solve this problem. it provides a straightforward way to support Zod 3 and Zod 4 (including Zod Mini) simultaneously. they can continue defining a single peerDependency on `"zod"`; no need for more arcane solutions like npm aliases, optional peer dependencies, or a `"zod-compat"` package. 

  Existing projects will be able upgrade Zod to the latest minor version (`zod@3.25`) to get access to `"zod/v4"` and its many improvements. (During the beta period, they can use `zod@next`.) The can do this with confidence that there will be zero breakage.

  Libraries will need to bump the minimum version of their `"zod"` peer dependency to `zod@^3.25.0`. They can then reference both Zod 3 and Zod 4 in their implementation:

  ```ts 
  import * as z3 from "zod/v3"
  import * as z4 from "zod/v4"
  ```

  Later, once there's broad support for v4, we'll bump the major version on npm and start exporting Zod 4 from the package root, completing the transition. Zod 3 will remain available at `"zod/v3"` forever. While it may seem unorthodox, this is the only approach I'm aware of that enables a clean, incremental migration path for both Zod's users and the libraries in the broader ecosystem.
</Accordion>
</Accordions>

## Parsing data

Now that we have a schema, we can parse some data with it. 

### `.parse()`

`.parse(data: unknown): T`

Given any Zod schema, use `.parse` to validate an input. If it's valid, Zod returns a strongly-typed *deep clone* of the input. 

```ts
Player.parse({ username: "billie", xp: 100 }); 
// => returns { username: "billie", xp: 100 }
```

Otherwise, a `ZodError` instance is thrown with detailed information about the validation issues.

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
try {
  Player.parse({ username: 42, xp: "100" });
} catch(err){
  if(error instanceof z.ZodError){
    err.issues; 
    /* [
      {
        expected: 'string',
        code: 'invalid_type',
        path: [ 'username' ],
        message: 'Invalid input: expected string'
      },
      {
        expected: 'number',
        code: 'invalid_type',
        path: [ 'xp' ],
        message: 'Invalid input: expected number'
      }
    ] */
  }
}
```
</Tab>
<Tab value="Zod Mini">
```ts
try {
  Player.parse({ username: 42, xp: "100" });
} catch(err){
  if(error instanceof z.core.$ZodError){
    err.issues; 
    /* [
      {
        expected: 'string',
        code: 'invalid_type',
        path: [ 'username' ],
        message: 'Invalid input: expected string'
      },
      {
        expected: 'number',
        code: 'invalid_type',
        path: [ 'xp' ],
        message: 'Invalid input: expected number'
      }
    ] */
  }
}
```
</Tab>
</Tabs>

<Callout>
**Note** — If your schema uses certain asynchronous APIs like `async` [refinements](#refine) or [transforms](#transform), you'll need to use the `.parseAsync()` method instead. 

```ts
const schema = z.string().refine(async (val) => val.length <= 8);

await schema.parseAsync("hello");
// => "hello"
```
</Callout>

### `.safeParse()`

`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`

To avoid `try/catch` blocks, use `.safeParse()`. This method returns an object containing either the successfully parsed data or a `ZodError`.

```ts
Player.safeParse({ username: "billie", xp: 100 });
// => { success: true; data: { username: "billie", xp: 100 } }

Player.safeParse({ username: 42, xp: "100" });
// => { success: false; error: ZodError }
```

The result type is a [discriminated union](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions), so you can handle both cases conveniently:

```ts
const result = stringSchema.safeParse("billie");
if (!result.success) {
  result.error;   // handle error
} else {
  result.data;    // do stuff
}
```

<Callout>
**Note** — If your schema uses certain asynchronous APIs like `async` [refinements](#refine) or [transforms](#transform), you'll need to use the `.safeParseAsync()` method instead. 

```ts
const schema = z.string().refine(async (val) => val.length <= 8);

await schema.safeParseAsync("hello");
// => { success: true; data: "hello" }
```
</Callout>



## Inferred types

Zod infers a static type from your schema definitions. You can extract this type with the `z.infer<>` utility and use it however you like.

```ts
const Player = z.object({ 
  username: z.string(),
  xp: z.number()
});

// extract the inferred type
type Player = z.infer<typeof Player>;

// use it in your code
const player: Player = { username: "billie", xp: 100 };
```

---

Now that we have the basics covered, let's jump into the Schema API.
