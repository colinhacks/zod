---
title: Codecs
description: "Bidirectional data transformation with encode and decode"
---

import { ThemedImage } from "@/components/themed-image";

All Zod schemas infer an `Input` and `Output` type. In most cases, these types are the same. 

```ts
const mySchema = z.string();

type Input = z.input<typeof mySchema>;   // => string
type Output = z.output<typeof mySchema>; // => string

```

However, certain schema types cause these types to diverge, like `.default()`, `.transform()` (unidirectional transformations), and `z.codec()` (bidirectional transformations).

```ts
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString), // ISO string → Date
    encode: (date) => date.toISOString(),       // Date → ISO string
  }
);

type Input = z.input<typeof stringToDate>;   // => string
type Output = z.output<typeof stringToDate>; // => Date
```

Zod provides APIs for processing data in both *decoding* ("forward" parsing) and *encoding* ("backward" parsing) directions. 

```ts
const payloadSchema = z.object({ date: stringToDate });

z.decode(payloadSchema, { date: "2024-01-15T10:30:00.000Z" });
// => { date: Date }

z.encode(payloadSchema, { date: new Date("2024-01-15T10:30:00.000Z") });
// => { date: string }
```

> **Note** —There's nothing special about the directions or terminology here. Instead of *encoding* with an `A -> B` codec, you could instead *decode* with a `B -> A` codec. The use of the terms "decode" and "encode" is just a convention.

This is particularly useful when parsing data at a network boundary. You can share a single Zod schema between your client and server, then use this single schema to convert between a network-friendly format (say, JSON) and a richer JavaScript representation.

<ThemedImage 
  lightSrc="/codecs-network-light.svg" 
  darkSrc="/codecs-network-dark.svg" 
  alt="Codecs encoding and decoding data across a network boundary" 
/>

## Decoding (forward)

Regular "parsing" processes data in the "forward" direction.

```ts
stringToDate.parse("2024-01-15T10:30:00.000Z"); 
// => Date
```

Here's the equivalent using Zod's top-level `z.decode()` function. This function accepts a schema as the first argument, and an input value as the second. (There is no `.decode()` method at this time.)

```ts
z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Date
```

Unlike the `.parse()` method which accepts `unknown`, `z.decode()` is strongly-typed—it expects the input value to conform to the schema's inferred *input type*.

```ts
stringToDate.parse(12345); 
// no complaints from TypeScript (but it will fail at runtime)

z.decode(stringToDate, 12345); 
// ❌ TypeScript error: Argument of type 'number' is not assignable to parameter of type 'string'.
```

<ThemedImage 
  lightSrc="/codecs-light.png" 
  darkSrc="/codecs-dark.png" 
  alt="Codec directionality diagram showing bidirectional transformation between input and output schemas" 
/>

As with regular parsing, there are "safe" and "async" variants as well.

```ts
z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Date

z.decodeAsync(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Promise<Date>

z.decodeSafe(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => { success: true, data: Date } | { success: false, error: ZodError }

z.decodeSafeAsync(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Promise<{ success: true, data: Date } | { success: false, error: ZodError }>
```

## Encoding (reverse)

To perform a "reverse parse" (encoding) operation, use the `z.encode()` function. 

```ts
z.encode(stringToDate, new Date("2024-01-15")); // => "2024-01-15T00:00:00.000Z"
```

> **Note** — The `.transform()` API implements a *unidirectional* transform that is not reversible. If a transform exists anywhere in your schema, attempting a `z.encode()` operation will throw a *runtime error* (not a `ZodError`).

As with regular parsing, there are "safe" and "async" variants as well.

```ts
z.encode(stringToDate, new Date("2024-01-15")); 
// => string

z.encodeAsync(stringToDate, new Date("2024-01-15")); 
// => Promise<string>

z.safeEncode(stringToDate, new Date("2024-01-15")); 
// => { success: true, data: string } | { success: false, error: ZodError }

z.safeEncodeAsync(stringToDate, new Date("2024-01-15")); 
// => Promise<{ success: true, data: string } | { success: false, error: ZodError }>
```

Most Zod schemas do not perform any transformation. As such, they behave identically in the both directions.

```ts
const schema = z.string();

z.decode(schema, "hello"); // => "hello"
z.encode(schema, "hello"); // => "hello"
```

The behavior only differs when certain *transforming schemas* exist in the schema hierarchy.

### Codecs

Codecs encapsulate a directional transformation between two types.

```ts
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString), // ISO string → Date
    encode: (date) => date.toISOString(),       // Date → ISO string
  }
);

z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Date

z.encode(stringToDate, new Date("2024-01-15")); 
// => string
```

### Defaults and prefaults

Defaults and prefaults are only applied in the "forward" direction. 

```ts
const stringWithDefault = z.string().default("hello");

z.decode(stringWithDefault, undefined); 
// => "hello"

z.encode(stringWithDefault, undefined); 
// => ZodError: Expected string, received undefined
```

This is sound. The inferred output type of `stringWithDefault` above is `string`. Non-string values (including `undefined`) are not valid inputs during encoding.

### Catch

"Catch" values are only applied in the "forward" direction.

```ts
const stringWithCatch = z.string().catch("hello");

z.decode(stringWithCatch, 1234); 
// => "hello"

z.encode(stringWithCatch, 1234); 
// => ZodError: Expected string, received number
```

### Stringbool

[Stringbool](/api#stringbool) transforms string values (`"true"`, `"false"`, `"yes"`, `"no"`, etc.) into `boolean`. During encoding, it converts `true` to `"true"` and `false` to `"false"`.

```ts
const stringbool = z.stringbool();

z.decode(stringbool, "true");  // => true
z.decode(stringbool, "false"); // => false

z.encode(stringbool, true);    // => "true"
z.encode(stringbool, false);   // => "false"
```

If you specify a custom set of `truthy` and `falsy` values, the first element in the array will be used instead.

```ts
const stringbool = z.stringbool({ truthy: ["yes", "y"], falsy: ["no", "n"] });

z.encode(stringbool, true);    // => "yes"
z.encode(stringbool, false);   // => "no"
```

### Transforms

⚠️ — The `.transform()` API implements a *unidirectional* transformation. If any `.transform()` exists anywhere in your schema, attempting a `z.encode()` operation will throw a *runtime error* (not a `ZodError`). 

```ts
const schema = z.string().transform(val => val.length);

z.encode(schema, 1234); 
// ❌ Error: Encountered unidirectional transform during encode: ZodTransform
```

{/* ### Success

`ZodSuccess` is also strictly unidirectional, and will throw an error if encountered during an encode operation.

```ts
const successSchema = z.success(z.string());

z.decode(successSchema, "hello"); 
// => true

z.encode(successSchema, true);    
// ❌ Error: Encountered unidirectional transform during encode: ZodSuccess
``` */}


## Examples

{/* Zod includes several built-in codecs for common use cases: */}

Below are some commonly necessary codecs. The implementations below have been tested. Feel free to copy/paste them into your project as needed.

### `stringToNumber`

Converts string representations of numbers to JavaScript `number` type using `parseFloat()`.

```ts
const stringToNumber = z.codec(z.string(), z.number(), {
  decode: (str) => Number.parseFloat(str),
  encode: (num) => num.toString(),
});

// Usage
z.decode(stringToNumber, "42.5");  // => 42.5
z.encode(stringToNumber, 42.5);    // => "42.5"
```

### `stringToInt`

Converts string representations of integers to JavaScript `number` type using `parseInt()`.

```ts
const stringToInt = z.codec(z.string(), z.int(), {
  decode: (str) => Number.parseInt(str, 10),
  encode: (num) => num.toString(),
});

// Usage
z.decode(stringToInt, "42");  // => 42
z.encode(stringToInt, 42);    // => "42"
```

### `stringToBigInt`

Converts string representations to JavaScript `bigint` type.

```ts
const stringToBigInt = z.codec(z.string(), z.bigint(), {
  decode: (str) => BigInt(str),
  encode: (bigint) => bigint.toString(),
});

// Usage
z.decode(stringToBigInt, "123456789012345678901234567890");  // => 123456789012345678901234567890n
z.encode(stringToBigInt, 123456789012345678901234567890n);   // => "123456789012345678901234567890"
```

### `numberToBigInt`

Converts JavaScript `number` to `bigint` type.

```ts
const numberToBigInt = z.codec(z.int(), z.bigint(), {
  decode: (num) => BigInt(num),
  encode: (bigint) => Number(bigint),
});

// Usage
z.decode(numberToBigInt, 42);   // => 42n
z.encode(numberToBigInt, 42n);  // => 42
```

### `isoDatetimeToDate`

Converts ISO datetime strings to JavaScript `Date` objects.

```ts
const isoDatetimeToDate = z.codec(z.iso.datetime(), z.date(), {
  decode: (isoString) => new Date(isoString),
  encode: (date) => date.toISOString(),
});

// Usage
z.decode(isoDatetimeToDate, "2024-01-15T10:30:00.000Z");  // => Date object
z.encode(isoDatetimeToDate, new Date("2024-01-15"));       // => "2024-01-15T00:00:00.000Z"
```

### `unixSecondsToDate`

Converts Unix timestamps (seconds since epoch) to JavaScript `Date` objects.

```ts
const unixSecondsToDate = z.codec(z.int().min(0), z.date(), {
  decode: (unixSeconds) => new Date(unixSeconds * 1000),
  encode: (date) => Math.floor(date.getTime() / 1000),
});

// Usage
z.decode(unixSecondsToDate, 1705314600);  // => Date object
z.encode(unixSecondsToDate, new Date());  // => Unix timestamp in seconds
```

### `unixMillisToDate`

Converts Unix timestamps (milliseconds since epoch) to JavaScript `Date` objects.

```ts
const unixMillisToDate = z.codec(z.int().min(0), z.date(), {
  decode: (unixMillis) => new Date(unixMillis),
  encode: (date) => date.getTime(),
});

// Usage
z.decode(unixMillisToDate, 1705314600000);  // => Date object
z.encode(unixMillisToDate, new Date());     // => Unix timestamp in milliseconds
```

### `json()`

Parses JSON strings into structured data and serializes back to JSON.

```ts
const json = <T extends z.ZodTypeAny>(schema: T) =>
  z.codec(z.string(), schema, {
    decode: (jsonString) => JSON.parse(jsonString),
    encode: (value) => JSON.stringify(value),
  });

// Usage
const codec = json(z.object({ name: z.string(), age: z.number() }));
z.decode(codec, '{"name":"Alice","age":30}');  // => { name: "Alice", age: 30 }
z.encode(codec, { name: "Bob", age: 25 });     // => '{"name":"Bob","age":25}'
```

### `utf8ToBytes`

Converts UTF-8 strings to `Uint8Array` byte arrays.

```ts
const utf8ToBytes = z.codec(z.string(), z.instanceof(Uint8Array), {
  decode: (str) => new TextEncoder().encode(str),
  encode: (bytes) => new TextDecoder().decode(bytes),
});

// Usage
z.decode(utf8ToBytes, "Hello, 世界!");  // => Uint8Array
z.encode(utf8ToBytes, bytes);          // => "Hello, 世界!"
```

### `bytesToUtf8`

Converts `Uint8Array` byte arrays to UTF-8 strings.

```ts
const bytesToUtf8 = z.codec(z.instanceof(Uint8Array), z.string(), {
  decode: (bytes) => new TextDecoder().decode(bytes),
  encode: (str) => new TextEncoder().encode(str),
});

// Usage
z.decode(bytesToUtf8, bytes);          // => "Hello, 世界!"
z.encode(bytesToUtf8, "Hello, 世界!");  // => Uint8Array
```

### `base64ToBytes`

Converts base64 strings to `Uint8Array` byte arrays and vice versa.

```ts
const base64ToBytes = z.codec(z.base64(), z.instanceof(Uint8Array), {
  decode: (base64String) => z.core.util.base64ToUint8Array(base64String),
  encode: (bytes) => z.core.util.uint8ArrayToBase64(bytes),
});

// Usage
z.decode(base64ToBytes, "SGVsbG8=");  // => Uint8Array([72, 101, 108, 108, 111])
z.encode(base64ToBytes, bytes);       // => "SGVsbG8="
```

### `base64urlToBytes`

Converts base64url strings (URL-safe base64) to `Uint8Array` byte arrays.

```ts
const base64urlToBytes = z.codec(z.base64url(), z.instanceof(Uint8Array), {
  decode: (base64urlString) => z.core.util.base64urlToUint8Array(base64urlString),
  encode: (bytes) => z.core.util.uint8ArrayToBase64url(bytes),
});

// Usage
z.decode(base64urlToBytes, "SGVsbG8");  // => Uint8Array([72, 101, 108, 108, 111])
z.encode(base64urlToBytes, bytes);      // => "SGVsbG8"
```

### `hexToBytes`

Converts hexadecimal strings to `Uint8Array` byte arrays and vice versa.

```ts
const hexToBytes = z.codec(z.hex(), z.instanceof(Uint8Array), {
  decode: (hexString) => z.core.util.hexToUint8Array(hexString),
  encode: (bytes) => z.core.util.uint8ArrayToHex(bytes),
});

// Usage
z.decode(hexToBytes, "48656c6c6f");     // => Uint8Array([72, 101, 108, 108, 111])
z.encode(hexToBytes, bytes);            // => "48656c6c6f"
```

### `stringToURL`

Converts URL strings to JavaScript `URL` objects.

```ts
const stringToURL = z.codec(z.url(), z.instanceof(URL), {
  decode: (urlString) => new URL(urlString),
  encode: (url) => url.href,
});

// Usage
z.decode(stringToURL, "https://example.com/path");  // => URL object
z.encode(stringToURL, new URL("https://example.com"));  // => "https://example.com/"
```

### `stringToHttpURL`

Converts HTTP/HTTPS URL strings to JavaScript `URL` objects.

```ts
const stringToHttpURL = z.codec(z.httpUrl(), z.instanceof(URL), {
  decode: (urlString) => new URL(urlString),
  encode: (url) => url.href,
});

// Usage
z.decode(stringToHttpURL, "https://api.example.com/v1");  // => URL object
z.encode(stringToHttpURL, url);                           // => "https://api.example.com/v1"
```

### `uriComponent`

Encodes and decodes URI components using `encodeURIComponent()` and `decodeURIComponent()`.

```ts
const uriComponent = z.codec(z.string(), z.string(), {
  decode: (encodedString) => decodeURIComponent(encodedString),
  encode: (decodedString) => encodeURIComponent(decodedString),
});

// Usage
z.decode(uriComponent, "Hello%20World%21");  // => "Hello World!"
z.encode(uriComponent, "Hello World!");      // => "Hello%20World!"
```

### `stringToBoolean()`

Converts string representations to boolean values. This is an alias for `z.stringbool()`.

```ts
const stringToBoolean = (options?: { truthy?: string[]; falsy?: string[] }) =>
  z.stringbool(options);

// Usage
const codec = stringToBoolean();
z.decode(codec, "true");   // => true
z.decode(codec, "false");  // => false
z.encode(codec, true);     // => "true"
z.encode(codec, false);    // => "false"

// With custom options
const customCodec = stringToBoolean({ truthy: ["yes", "y"], falsy: ["no", "n"] });
z.decode(customCodec, "yes");  // => true
z.encode(customCodec, true);   // => "yes"
```
