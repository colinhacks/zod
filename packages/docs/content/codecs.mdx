---
title: Codecs
description: "Bidirectional data transformation with encode and decode"
---

import { ThemedImage } from "@/components/themed-image";

All Zod schemas infer an `Input` and `Output` type. In most cases, these types are the same. 

```ts
const mySchema = z.string();

type Input = z.input<typeof mySchema>;   // => string
type Output = z.output<typeof mySchema>; // => string

```

However, certain schema types cause these types to diverge, like `.default()`, `.transform()` (unidirectional transformations), and `z.codec()` (bidirectional transformations).

```ts
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString), // ISO string → Date
    encode: (date) => date.toISOString(),       // Date → ISO string
  }
);

type Input = z.input<typeof stringToDate>;   // => string
type Output = z.output<typeof stringToDate>; // => Date
```

Zod provides APIs for processing data in both *decoding* ("forward" parsing) and *encoding* ("backward" parsing) directions. 

```ts
const payloadSchema = z.object({ date: stringToDate });

z.decode(payloadSchema, { date: "2024-01-15T10:30:00.000Z" });
// => { date: Date }

z.encode(payloadSchema, { date: new Date("2024-01-15T10:30:00.000Z") });
// => { date: string }
```

> **Note** —There's nothing special about the directions or terminology here. Instead of *encoding* with an `A -> B` codec, you could instead *decode* with a `B -> A` codec. The use of the terms "decode" and "encode" is just a convention.

This is particularly useful when parsing data at a network boundary. You can share a single Zod schema between your client and server, then use this single schema to convert between a network-friendly format (say, JSON) and a richer JavaScript representation.

<ThemedImage 
  lightSrc="/codecs-network-light.svg" 
  darkSrc="/codecs-network-dark.svg" 
  alt="Codecs encoding and decoding data across a network boundary" 
/>

## Decoding (forward)

Regular "parsing" processes data in the "forward" direction.

```ts
stringToDate.parse("2024-01-15T10:30:00.000Z"); 
// => Date
```

Here's the equivalent using Zod's top-level `z.decode()` function. This function accepts a schema as the first argument, and an input value as the second. (There is no `.decode()` method at this time.)

```ts
z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Date
```

Unlike the `.parse()` method which accepts `unknown`, `z.decode()` is strongly-typed—it expects the input value to conform to the schema's inferred *input type*.

```ts
stringToDate.parse(12345); 
// no complaints from TypeScript (but it will fail at runtime)

z.decode(stringToDate, 12345); 
// ❌ TypeScript error: Argument of type 'number' is not assignable to parameter of type 'string'.
```

<ThemedImage 
  lightSrc="/codecs-light.png" 
  darkSrc="/codecs-dark.png" 
  alt="Codec directionality diagram showing bidirectional transformation between input and output schemas" 
/>

As with regular parsing, there are "safe" and "async" variants as well.

```ts
z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Date

z.decodeAsync(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Promise<Date>

z.decodeSafe(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => { success: true, data: Date } | { success: false, error: ZodError }

z.decodeSafeAsync(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Promise<{ success: true, data: Date } | { success: false, error: ZodError }>
```

## Encoding (reverse)

To perform a "reverse parse" (encoding) operation, use the `z.encode()` function. 

```ts
z.encode(stringToDate, new Date("2024-01-15")); // => "2024-01-15T00:00:00.000Z"
```

> **Note** — The `.transform()` API implements a *unidirectional* transform that is not reversible. If a transform exists anywhere in your schema, attempting a `z.encode()` operation will throw a *runtime error* (not a `ZodError`).

As with regular parsing, there are "safe" and "async" variants as well.

```ts
z.encode(stringToDate, new Date("2024-01-15")); 
// => string

z.encodeAsync(stringToDate, new Date("2024-01-15")); 
// => Promise<string>

z.safeEncode(stringToDate, new Date("2024-01-15")); 
// => { success: true, data: string } | { success: false, error: ZodError }

z.safeEncodeAsync(stringToDate, new Date("2024-01-15")); 
// => Promise<{ success: true, data: string } | { success: false, error: ZodError }>
```

Most Zod schemas do not perform any transformation. As such, they behave identically in the both directions.

```ts
const schema = z.string();

z.decode(schema, "hello"); // => "hello"
z.encode(schema, "hello"); // => "hello"
```

The behavior only differs when certain *transforming schemas* exist in the schema hierarchy.

### Codecs

Codecs encapsulate a directional transformation between two types.

```ts
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString), // ISO string → Date
    encode: (date) => date.toISOString(),       // Date → ISO string
  }
);

z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); 
// => Date

z.encode(stringToDate, new Date("2024-01-15")); 
// => string
```

### Defaults and prefaults

Defaults and prefaults are only applied in the "forward" direction. 

```ts
const stringWithDefault = z.string().default("hello");

z.decode(stringWithDefault, undefined); 
// => "hello"

z.encode(stringWithDefault, undefined); 
// => ZodError: Expected string, received undefined
```

This is sound. The inferred output type of `stringWithDefault` above is `string`. Non-string values (including `undefined`) are not valid inputs during encoding.

### Catch

"Catch" values are only applied in the "forward" direction.

```ts
const stringWithCatch = z.string().catch("hello");

z.decode(stringWithCatch, 1234); 
// => "hello"

z.encode(stringWithCatch, 1234); 
// => ZodError: Expected string, received number
```

### Stringbool

[Stringbool](/api#stringbool) transforms string values (`"true"`, `"false"`, `"yes"`, `"no"`, etc.) into `boolean`. During encoding, it converts `true` to `"true"` and `false` to `"false"`.

```ts
const stringbool = z.stringbool();

z.decode(stringbool, "true");  // => true
z.decode(stringbool, "false"); // => false

z.encode(stringbool, true);    // => "true"
z.encode(stringbool, false);   // => "false"
```

If you specify a custom set of `truthy` and `falsy` values, the first element in the array will be used instead.

```ts
const stringbool = z.stringbool({ truthy: ["yes", "y"], falsy: ["no", "n"] });

z.encode(stringbool, true);    // => "yes"
z.encode(stringbool, false);   // => "no"
```

### Transforms

⚠️ — The `.transform()` API implements a *unidirectional* transformation. If any `.transform()` exists anywhere in your schema, attempting a `z.encode()` operation will throw a *runtime error* (not a `ZodError`). 

```ts
const schema = z.string().transform(val => val.length);

z.encode(schema, 1234); 
// ❌ Error: Encountered unidirectional transform during encode: ZodTransform
```

{/* ### Success

`ZodSuccess` is also strictly unidirectional, and will throw an error if encountered during an encode operation.

```ts
const successSchema = z.success(z.string());

z.decode(successSchema, "hello"); 
// => true

z.encode(successSchema, true);    
// ❌ Error: Encountered unidirectional transform during encode: ZodSuccess
``` */}

{/* 
## Built-ins

Zod includes several built-in codecs for common use cases:


```ts
// numbers / bigint
z.codec.stringToNumber(); // parseFloat() / toString()
z.codec.stringToInt(); // parseInt() / toString()
z.codec.stringToBigInt(); // BigInt() / toString()
z.codec.numberToBigInt(); // BigInt() / toString()

// dates / durations
z.codec.isoDatetimeToDate(); // new Date() / toISOString()
z.codec.unixSecondsToDate(); // new Date() / getTime() / 1000
z.codec.unixMillisToDate(); // new Date() / getTime()

// json
z.codec.json(); // decode w/ JSON.parse(), encode w/ JSON.stringify()

// text ⇄ bytes
z.codec.utf8ToBytes(); // decode w/ TextEncoder, encode w/ TextDecoder
z.codec.bytesToUtf8(); // decode w/ TextDecoder, encode w/ TextEncoder

// binary-to-text ⇄ bytes
z.codec.base64(); // util.base64ToUint8Array(), util.uint8ArrayToBase64()
z.codec.base64url(); // util.base64urlToUint8Array(), util.uint8ArrayToBase64url()
z.codec.hex(); // util.hexToUint8Array(), util.uint8ArrayToHex()

// urls
z.codec.stringToURL(); // decode w/ new URL(), encode w/ .href
z.codec.stringToHttpURL(); // same but use httpURL for input string
z.codec.uriComponent(); // decode w/ decodeURIComponent(), encode w/ encodeURIComponent()

// boolean
z.codec.stringToBoolean(); // alias of z.stringbool()

// dependency injection (do not implement, but document)
z.codec.isoDurationToMilliseconds(); // 
z.codec.stringToBigDecimal(); 
z.codec.
``` */}
  